
#if defined(__XS3A__)


/*  
void conv2d_deepin_deepout_relu_asm(
    const int8_t* K, 
    const data16_t* B,
    const int8_t* X, 
    int8_t* Y,
    const int32_t height, 
    const int32_t width,
    const int32_t K_h, 
    const int32_t K_w,
    const int32_t C_out, 
    const int32_t C_in,
    const int16_t* shifts, 
    const int16_t* scales);
*/

#define FUNCTION_NAME conv2d_deepin_deepout_relu_asm

#define NSTACKWORDS  20
    
.text
.issue_mode  dual
.globl FUNCTION_NAME
.align 4
.type FUNCTION_NAME,@function
.cc_top FUNCTION_NAME.function,FUNCTION_NAME

#define NOOOOP          nop
    
#define arg_K               r0
#define arg_B               r1
#define arg_X               r2
#define arg_Y               r3


#define STACK_HEIGHT        (NSTACKWORDS+1)
#define STACK_WIDTH         (NSTACKWORDS+2)
#define STACK_K_H           (NSTACKWORDS+3)
#define STACK_K_W           (NSTACKWORDS+4)
#define STACK_C_OUT         (NSTACKWORDS+5)
#define STACK_C_IN          (NSTACKWORDS+6)
#define STACK_SHIFTS        (NSTACKWORDS+7)
#define STACK_SCALES        (NSTACKWORDS+8)

#define STACK_K_START
#define STACK_CUR_X
#define STACK_BIASES_LO     
#define STACK_BIASES_HI
#define STACK_ROWS_LEFT     
#define STACK_COLS_LEFT            
#define STACK_K_H_HALF      
#define STACK_K_W_HALF      
#define STACK_IMG_ROW_BYTES 
#define STACK_C_IN_CHK
#define STACK_C_OUT_CHK

#define STACK_PAD_LEFT      
#define STACK_PAD_RIGHT     
#define STACK_PAD_TOP       
#define STACK_PAD_BOTTOM    



FUNCTION_NAME:
    dualentsp NSTACKWORDS
// we need all the registers
    std r4, r5, sp[0]
    std r6, r7, sp[1]
    std r8, r9, sp[2]
    {   NOOOOP                                  ;   stw r10, sp[6]                      }

//store kernel tensor start address on stack. We'll need it for each pixel
    {   NOOOOP                                  ;   stw arg_K, sp[STACK_K_START]        }
//store half-kernel sizes on stack
    {   NOOOOP                                  ;   ldw r4, sp[STACK_K_H]               }
    {   shr r4, r4, 1                           ;   ldw r5, sp[STACK_K_W]               }
    {   shr r5, r5, 1                           ;   stw r4, sp[STACK_K_H_HALF]          }
    {   NOOOOP                                  ;   stw r5, sp[STACK_K_H_HALF]          }
//move X to point at pixel location X[-K_H/2][-K_W/2]
    {   NOOOOP                                  ;   ldw r7, sp[STACK_C_IN]              }
    mul r5, r5, r7  // r5 = (K_W/2) * C_in
    {   sub r0, r0, r5                          ;   ldw r5, sp[STACK_WIDTH]             }
    mul r6, r5, r7  // r6 = width * C_in
    {   NOOOOP                                  ;   stw r6, sp[STACK_IMG_ROW_BYTES]     }   //while we're at it, save image row bytes
    mul r4, r4, r6  // r4 = (K_H/2) * (width * C_in)
    {   sub r0, r0, r4                          ;   NOOOOP                              }
    {   NOOOOP                                  ;   stw r0, sp[STACK_CUR_X]             }
//store bias pointers on stack
    {   NOOOOP                                  ;   ldw r5, sp[STACK_C_OUT]             }
    {   lda16 arg_B, arg_B[r5]                  ;   stw arg_B, sp[STACK_BIASES_LO]      } 
    {   NOOOOP                                  ;   stw arg_B, sp[STACK_BIASES_HI]      }
//shifts and scales are already on stack
    {   NOOOOP                                  ;   NOOOOP                              }
//store remaining ROWS and COLS on stack (height,width)
    {   NOOOOP                                  ;   ldw r0, sp[STACK_WIDTH]             }
    {   NOOOOP                                  ;   ldw r1, sp[STACK_HEIGHT]            }
    {   NOOOOP                                  ;   stw r0, sp[STACK_ROWS_LEFT]         }
    {   NOOOOP                                  ;   stw r1, sp[STACK_COLS_LEFT]         }
//store C_in/32 and C_out/16 on stack
    {   NOOOOP                                  ;   ldw r5, sp[STACK_C_IN]              }
    {   shr r5, r5, 5                           ;   ldw r6, sp[STACK_C_OUT]             }
    {   shr r6, r6, 4                           ;   stw r5, sp[STACK_C_IN_CHK]          }
    {   NOOOOP                                  ;   stw r6, sp[STACK_C_OUT_CHK]         }

// initialize STACK_PAD_TOP and STACK_PAD_BOTTOM
    {   NOOOOP                                  ;   ldw r0, sp[STACK_K_H_HALF]          }
    {   NOOOOP                                  ;   ldw r1, sp[STACK_HEIGHT]            } //height of 1 means K_H_HALF padding
    {   sub r1, r1, 1                           ;   stw r0, sp[STACK_PAD_TOP]           } // height of 2 means K_H_HALF - 1 padding
    {   lss r0,                                ;   stw r0, sp[STACK_PAD_TOP]            } // bottom padding = MIN(K_H_HALF-(height-1), 0)
    {   NOOOOP                                  ;   stw r0, sp[STACK_PAD_BOTTOM]        }


/**
 * Things we need to know to do a complete patch (when not near padding):
 *  - X location of top-left of patch
 *  - K location of top-left of patch
 *  -* Row count
 *  -* maccs per patch row / 16
 *  - patch row increment (e.g. add this to X patch location (at the end of the patch row) to get to start of next)
 *  - kernel row increment (because of padding)
 *  - C_out/16 (iterate over groups of output channels) (reasonable candidate for putting on stack -- outer loop)
 *  - Y location
 *  -^ biases (lo)  - pass in register, save to stack
 *  -^ biases (hi)  - pass in register, save to stack
 *  -^ shifts       - pass in register, save to stack
 *  -^ scales       - pass in register, save to stack
 * 
 *   *should be provided via stack
 *   ^pass via register, save on stack
 */
#define patch_x             r0
#define patch_k             r1
#define patch_row_incr      r2
#define patch_y             r3
#define cout_left           r4
#define kernel_row_incr     r5

#define STACK_PATCH_ROWS    
#define STACK_ROW_MACCS     
#define STACK_BIAS_LO_TMP          
#define STACK_BIAS_HI_TMP   
#define STACK_SHIFTS_TMP    
#define STACK_SCALES_TMP
#define STACK_X_INITIAL    
#define STACK_K_JMP                 //jump from bottom-right of patch_k to the top-left of the next output channel's kernel

/*
// Need to calculate:
    - r0 - X location of top-left of patch. Add rows/cols to STACK_CUR_X to avoid padding 
                             = STACK_CUR_X + IMG_ROW_BYTES * top_padding + C_in * left_padding
    - r1 - K location of top-left of patch. Add rows/cols to STACK_K_START to avoid padding
                             = STACK_K_START + C_in * K_W * top_padding + C_in * left_padding
    - r2 - Increment added to patch_x after each row to go to left cell of patch_x in the next row
                             = C_in * (left_padding+right_padding)
        - r3 - patch_y - do nothing. it's already in the right spot.
        - r4 - initialize this to STACK_C_OUT_CHK (maybe -1)
    - r5 - Increment added to patch_k after each row to go to left cell of patch_k in the next row

        - STACK_PATCH_ROWS - number of non-padding rows in this patch
    - STACK_ROW_MACCS - number of MACC groups per row in this patch (STACK_C_IN_CHK * columns in patch)
        - STACK_BIAS_LO_TMP - STACK_BIAS_LO
        - STACK_BIAS_HI_TMP - STACK_BIAS_HI
        - STACK_SHIFTS_TMP - STACK_SHIFTS
        - STACK_SCALES_TMP - STACK_SCALES
    - STACK_K_JMP - argument to 'ldaw patch_k, patch_k[THIS]'    THIS = K_W - padding_cols

So, I quickly need to 
*/

.L_pix_pos_start:
//bias, shifts, scales  -- these can be made to use ldd/std instead!! half the instructions!
    {   NOOOOP                                  ;   ldw r9, sp[STACK_BIASES_LO]         }
    {   NOOOOP                                  ;   stw r9, sp[STACK_BIAS_LO_TMP]       }
    {   NOOOOP                                  ;   ldw r9, sp[STACK_BIASES_HI]         }
    {   NOOOOP                                  ;   stw r9, sp[STACK_BIASES_LO]         }
    {   NOOOOP                                  ;   ldw r9, sp[STACK_SHIFTS]            }
    {   NOOOOP                                  ;   stw r9, sp[STACK_SHIFTS_TMP]        }
    {   NOOOOP                                  ;   ldw r9, sp[STACK_SCALES]            }
    {   NOOOOP                                  ;   stw r9, sp[STACK_SCALES_TMP]        }
//figure out top, left, right and bottom padding
    {   NOOOOP                                  ;   ldw r11, sp[STACK_ROWS_LEFT]        }
    {   ldc r7, 0                               ;   ldw r10, sp[STACK_HEIGHT]           }
    {   sub r8, r11, r10                        ;   ldw r9,  sp[STACK_K_H_HALF]         }   
    {   add r8, r8, r9                          ;   NOOOOP                              } 
    {   lss r6, r8, r7                          ;   NOOOOP                              }
    mul r8, r8, r6  //r8 = MAX(K_H_HALF + (rows_left - height), 0) - top padding
    {   sub r11, r11, 1                         ;   NOOOOP                              }
    {   lss r6, r11, r9                         ;   NOOOOP                              }   //r6 = (ROWS_LEFT-1) < K_H_HALF
    {   sub r7, r11, r9                         ;   ldw r5, sp[STACK_K_H]               }
    mul r7, r7, r6  //r7 = ((ROWS_LEFT-1) - K_H_HALF) ((ROWS_LEFT-1) < K_H_HALF) - bottom padding

    {   sub r5, r5, r7                          ;   NOOOOP                              }
    {   sub r5, r5, r8                          ;   NOOOOP                              }
    {   NOOOOP                                  ;   stw r6, sp[STACK_PATCH_ROWS]        }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
    {   NOOOOP                                  ;   NOOOOP                              }
//initialize output channel iterator
    {   NOOOOP                                  ;   ldw cout_left, sp[STACK_C_OUT_CHK]  }



////////////////////////////////////////////////////////////////////////////////////////////////////////
.L_patch_start:
    {   NOOOOP                                  ;   stw patch_x,  sp[STACK_X_INITIAL]   }


#define row_iter        r6
#define row_macc_iter   r7
#define tmp1            r11

.L_patch_chan_start:
    {   ldc r11, 1                              ;   ldw row_iter, sp[STACK_PATCH_ROWS]      }
    {   shl r11, 9                              ;   ldw row_macc_iter, sp[STACK_ROW_MACCS]  }
    {   NOOOOP                                  ;   vsetc r11                               }

//load biases
    {   NOOOOP                                  ;   ldw tmp1, sp[STACK_BIAS_LO_TMP]         }
    {   ldaw tmp1, tmp1[8]                      ;   vldr tmp1[0]                            }
    {   NOOOOP                                  ;   stw tmp1, sp[STACK_BIAS_LO_TMP]         }
    {   NOOOOP                                  ;   ldw tmp1, sp[STACK_BIAS_HI_TMP]         }
    {   ldaw tmp1, tmp1[8]                      ;   vldd tmp1[0]                            }
    {   NOOOOP                                  ;   stw tmp1, sp[STACK_BIAS_HI_TMP]         }
//reset patch_x to beginning
    {   NOOOOP                                  ;   ldw patch_x, sp[STACK_X_INITIAL]        }

.L_patch_sum_start:
    {   NOOOOP                                  ;   NOOOOP                              }

.L_patch_row_start:
    {   NOOOOP                                  ;   ldw macc_cnt, sp[STACK_ROW_MACCS] }
.L_patch_row_loop:
    {   ldaw patch_x, patch_x[8]                ;   vldc patch_x[0]                     }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
    {   ldaw patch_k, patch_k[8]                ;   vlmaccr patch_k[0]                  }
.L_patch_row_maccs_end:
    {   sub macc_cnt, macc_cnt, 1               ;   NOOOOP                              }
    {   NOOOOP                                  ;   bt macc_cnt, .L_patch_row_loop      }
    {   add patch_x, patch_x, patch_row_incr    ;   NOOOOP                              }
    {   add patch_k, patch_k, kernel_row_incr   ;   NOOOOP                              }
    {   sub k_rows, k_rows, 1                   ;   NOOOOP                              }
    {   NOOOOP                                  ;   bt k_rows, .L_patch_row_start       }
.L_patch_sum_end:
    {   ldc r11, 1                              ;   ldw TMP1, sp[STACK_SHIFTS_TMP]      }
    {   shl r11, r11, 8                         ;   NOOOOP                              }
    {   NOOOOP                                  ;   vsetc r11                           }
    {   ldaw TMP1, TMP1[8]                      ;   vlsat TMP1[0]                       }
    {   ldaw TMP1, sp[STACK_TMP_VEC]            ;   stw TMP1, sp[STACK_SHIFTS_TMP]      }
    {   NOOOOP                                  ;   vpos                                }
    {   ldaw r11, sp[STACK_SUB_VEC]             ;   vstr TMP1[0]                        }
    {   NOOOOP                                  ;   vldr r11[0]                         }
    {   NOOOOP                                  ;   vlsub TMP1[0]                       }
    {   NOOOOP                                  ;   ldw TMP1, sp[STACK_SCALES_TMP]      }
    {   add TMP1, TMP1, TMP2                    ;   vlmul TMP1[0]                       }
    {   mkmsk TMP1, 16                          ;   stw TMP1, sp[STACK_SCALES_TMP]      }
    {   NOOOOP                                  ;   vdepth8                             }
    vstrpv Y[0], TMP1
    {   ldaw Y, Y[4]                            ;   NOOOOP                              }

.L_patch_end:

    {   NOOOOP                                  ;   NOOOOP                              }
////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Move our X pointer to look at the next pixel in the row
    {   NOOOOP                                  ;   ldw r1, sp[STACK_CUR_X]             }
    {   NOOOOP                                  ;   ldw r2, sp[STACK_C_IN]              }
    {   add r1, r1, r2                          ;   ldw r2, sp[STACK_COL_REM]           }
    {   sub r2, r2, 1                           ;   stw r1, sp[STACK_CUR_X]             }
    {   NOOOOP                                  ;   bt r2, .L_tmp_same_row              }
//new column
    {   NOOOOP                                  ;   ldw r1, sp[STACK_POS_COL]           }
    {   sub r1, r1, 1                           ;   ldw r2, sp[STACK_WIDTH]             }
    {   NOOOOP                                  ;   bf r1, .Lfunc_end                   } //if STACK_POS_COL == 0 we're done
    {   NOOOOP                                  ;   stw r1, sp[STACK_POS_COL]           }
.L_tmp_same_row:
    {   NOOOOP                                  ;   stw r2, sp[STACK_COL_REM]           }
    {   NOOOOP                                  ;   NOOOOP                              }



.Lfunc_end:
    {   NOOOOP                                  ;   ldw r10, sp[6]                      }
    ldd r8, r9, sp[2]
    ldd r6, r7, sp[1]
    ldd r4, r5, sp[0]
    retsp NSTACKWORDS

    .cc_bottom FUNCTION_NAME.function
    .set FUNCTION_NAME.nstackwords,NSTACKWORDS
    .globl FUNCTION_NAME.nstackwords
    .set FUNCTION_NAME.maxcores,1
    .globl FUNCTION_NAME.maxcores
    .set FUNCTION_NAME.maxtimers,0
    .globl FUNCTION_NAME.maxtimers
    .set FUNCTION_NAME.maxchanends,0
    .globl FUNCTION_NAME.maxchanends
.Ltmp0:
    .size FUNCTION_NAME, .Ltmp0-FUNCTION_NAME
    .issue_mode  single

#endif



